## 문제

https://www.acmicpc.net/problem/1018

약 `1시간 30분` 소요

## 풀이

`브루트 포스` 알고리즘으로 모든 경우의 수를 찾으면 되는 문제이었습니다.

처음에는 모든 경우의 수를 찾으면 `시간 복잡도` 가 높아서 문제가될 것이라고 생각해서 더 나은 방법이 없는지 생각해보았지만 다른 방법이 떠오르지 않아 `브루트 포스` 방식으로 문제를 풀의했으며 해결할 수 있었습니다.

문제를 풀면서 고민되었던 부분은 `BW` 와 `WB` 으로 시작되는 것을 각각 구해서 계산해야 하는가? 고민이 있었는데 `홀짝` 방식의 `토글` 을 통해 구할 수 있도록 처리했습니다.

## 실수

- 입력 값의 범위를 받아오는데 해당 값을 사용하지 않고 순회하면서 조사한 것
  - 입력 값의 최대 범위인 `50 * 50` 에 맞게 `배열` 을 할당했는데 계산 시 실제 입력된 값의 범위를 구할려고 `50 * 50` 의 배열을 순회하면서 `if (!arr[i][j])` 인 경우 `continue;` 하도록 구현했는데 사전에 `N` , `M` 으로 입력 받을 값의 범위를 받아오므로 불필요하게 범위를 구할 필요가 없었음
  - 이것을 알기 이전에는 값 존재 여부 확인이 필요했는데 확인을 위해서는 `board` 를 봐야하는데 `reColoring` 과 같은 다른 변수를 보고 있던 문제가 있었음
- `Y` 입력의 최대 값은 `N` 인데 `M` 으로 실수로 지정한 부분이 있음
- `mask` 돌릴 때 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, <u>변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다.</u> 를 위해서는 한줄 내려갈 때 마다 `BW` 으로 칠했다면 다음 칸은 `WB` 와 같이 돌려줘야 하는데 이부분을 처리하지 않았음
- `N` 과 `M` 은 `cin` 으로 받고 `체스판` 은 `getline` 으로 받는데 `cin` 이후 `\n` 이 `getline` 첫 호출 시 `공백` 으로 들어오는 문제가 있어서 `cin.ignore()` 해결
